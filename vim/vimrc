set nocompatible

" FIXME: need a keyboard shortcut to close buffers `goterm://*`

" FIXME: move these somewhere
function! GetVisual()
    try
        let v_save = @v
        normal! gv"vy
        return @v
    finally
        let @v = v_save
    endtry
endfunction

fun! CenterMe()
    let v = GetVisual()
    "let l = getline('.')
    let lre = '^\zs\s*\ze\S'
    let rre = '\s*$'
    let sp= matchstr(v,lre)
    let sp .= matchstr(v,rre)
    let ln=len(sp)
    let v = substitute(v,lre,sp[:ln/2-1],'')
    let v = substitute(v,rre,sp[ln/2:],'')
    let ve_save = &virtualedit
    let v_save = @v
    let &virtualedit = 'all'
    call setreg('v', v,visualmode())
    normal! gvx"vP
    let @v = v_save
    let &virtualedit = ve_save
endf

" TODO
" Start a new change before deleting with Ctrl+u, so a normal mode "u" can still
" recover the deleted word or line.  Normally Ctrl+u while in insert mode
" would delete the text without undo history and it would be lost forever.
" inoremap <c-u> <c-g>u<c-u>
" inoremap <c-w> <c-g>u<c-w>
"
" remap these so next term gets centered on screen: /?Nn to <x>zz
"
" does the rst title underline thing
" nnoremap <Leader>1 yypVr=
" nnoremap <Leader>2 yypVr-
"
" insert blank line above/below but stay in normal mode
" nnoremap <Leader>l <ESC>:put =''<CR>
" nnoremap <Leader>L <ESC>:put! =''<CR>

" Autocompletion of filenames in insert mode.  Ctrl+d will abort.
" inoremap <c-f> <c-x><c-f>
" nmap <c-f> i<c-f>
" Complete and go in folder.
" inoremap <c-l> <right><c-x><c-f>

" vim-plug auto-install {{{
let data_dir = has('nvim') ? stdpath('config') . '/' : '~/.vim'
if empty(glob(data_dir . '/autoload/plug.vim'))
  silent exec '!curl -fLo '.data_dir.'/autoload/plug.vim --create-dirs  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
  au VimEnter * PlugInstall --sync | source $MYVIMRC
endif

" FIXME
" set switchbuf=useopen

" }}}

" PLUGINS {{{
call plug#begin('~/.vim/plugged')

" my own stuff
Plug 'shaunduncan/dotfiles', {
  \ 'dir': '~/.config/dotfiles',
  \ 'rtp': 'vim',
  \ 'frozen': v:true
  \ }

" Plug 'Raimondi/delimitMate'
" Plug 'szw/vim-maximizer' ... alternative to zoom tab

" filetype/language support {{{

" don't use vim-go/ale for neovim
if !has('nvim')
  Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }
  Plug 'dense-analysis/ale'
endif

Plug 'cespare/vim-toml',         { 'for': 'toml' }
Plug 'hashivim/vim-terraform',   { 'for': 'terraform' }
Plug 'uarun/vim-protobuf',       { 'for': 'proto' }
Plug 'vim-python/python-syntax', { 'for': 'python' }
Plug 'preservim/vim-markdown',   { 'for': 'markdown' }
Plug 'udalov/kotlin-vim'
" }}}

" dev tools {{{
Plug 'AndrewRadev/quickpeek.vim'
Plug 'Konfekt/FastFold'
Plug 'SirVer/ultisnips'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-surround'

" markdown utils
Plug 'junegunn/goyo.vim',      { 'for': 'markdown' }
Plug 'junegunn/limelight.vim', { 'for': 'markdown' }

" git tools
Plug 'tpope/vim-fugitive'
Plug 'shumphrey/fugitive-gitlab.vim'
Plug 'junegunn/gv.vim'

" some personalizations and custom mods
Plug 'shaunduncan/tagbar'  " preservim/tagbar

" neovim specific {{{

if has('nvim')
  " requirement for some
  Plug 'nvim-lua/plenary.nvim'

  " debugging
  " Plug 'mfussenegger/nvim-dap'
  " Plug 'rcarriga/nvim-dap-ui'
  " Plug 'leoluz/nvim-dap-go', { 'for': 'go' }

  " lsp
  Plug 'nvim-treesitter/nvim-treesitter'
  Plug 'neovim/nvim-lspconfig'
  Plug 'williamboman/mason.nvim'
  Plug 'williamboman/mason-lspconfig.nvim'
  Plug 'glepnir/lspsaga.nvim', { 'branch': 'main' }

  " golang
  Plug 'ray-x/go.nvim'
  Plug 'ray-x/guihua.lua'

  " lsp symbols in fzf
  Plug 'gfanto/fzf-lsp.nvim'

  " try out completion at some point?
  " Plug 'hrsh7th/cmp-nvim-lsp'
  " Plug 'hrsh7th/cmp-buffer'
  " Plug 'hrsh7th/cmp-path'
  " Plug 'hrsh7th/cmp-nvim-lua'
  " Plug 'hrsh7th/nvim-cmp'

  " git
  Plug 'sindrets/diffview.nvim'

  " other
  Plug 'sindrets/winshift.nvim'

  " integration with glow to render markdown
  Plug 'ellisonleao/glow.nvim'
  Plug 'JASONews/glow-hover.nvim'

  " dim non-active buffers
  " Plug 'sunjon/Shade.nvim'
  " Plug 'folke/twilight.nvim'
  Plug 'RRethy/nvim-base16'

  Plug 'jbyuki/venn.nvim'
endif

" }}}

" }}}

" vim utilities {{{
Plug 'gcmt/taboo.vim'
Plug 'godlygeek/tabular'
Plug 'ivyl/vim-bling'
Plug 'jeetsukumaran/vim-buffergator'
Plug 'kshenoy/vim-signature'
Plug 'liuchengxu/vim-which-key'
Plug 'mbbill/undotree'
Plug 'skywind3000/asyncrun.vim'
Plug 'troydm/zoomwintab.vim'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'zhimsel/vim-stay'
" }}}

" other utils {{{
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
Plug 'vimwiki/vimwiki'
" }}}

" debug tools {{{
" Plug 'dstein64/vim-startuptime'
" }}}

" Plug 'flazz/vim-colorschemes'
" Plug 'felixhummel/setcolors.vim'

" TODO: potential alternative to netrw
" Plug 'lambdalisue/fern.vim'

" colorschemes
Plug 'vv9k/vim-github-dark'
Plug 'dikiaap/minimalist'
Plug 'ayu-theme/ayu-vim'
Plug 'ayu-theme/ayu-vim-airline'

call plug#end()
" }}}

" VARS {{{

" custom theme options (uncomment to use a custom built theme)
" let g:my_theme=get(environ(), 'MY_THEME', 'my_nova')

" terminal_ansi_colors
" FIXME: need a consistent color set for error/warning
let g:my_theme_overrides=
  \ ['core coloring', [
  \   #{group: ['CursorLineNr'], attrs: 'bold'},
  \   #{group: ['Error'], guifg: 'black', ctermfg: 'black'},
  \   #{group: ['ErrorMsg'], from: 'Error', attrs: 'reverse', strategy: 'replace'},
  \   #{group: ['Folded', 'FoldColumn'], from: 'SpellRare', guifg: 'Cyan', guibg: 'NONE', ctermbg: 'NONE', attrs: 'NONE', strategy: 'replace'},
  \   #{group: ['IncSearch', 'MatchParen'], linksto: 'Search'},
  \   #{group: ['Italic'], attrs: 'italic'},
  \   #{group: ['SpellBad', 'SpellLocal', 'SpellCap', 'SpellRare'], attrs: 'undercurl'},
  \   #{group: ['SignColumn'], strategy: 'replace'},
  \   #{group: ['vim9Comment'], linksto: 'Error'},
  \ ]][1] +
  \ ['ale', [
  \   #{group: ['ALEErrorSign', 'ALEFloatingPreviewError', 'ALEFloatingPreviewStyleError'], from: 'ErrorMsg'},
  \   #{group: ['ALEWarningSign', 'ALEFloatingPreviewWarning', 'ALEFloatingPreviewStyleWarning'], from: 'WarningMsg'},
  \   #{group: ['ALEErrorSign', 'ALEWarningSign'], attrs: 'reverse'},
  \ ]][1] +
  \ ['markdown', [
  \   #{group: ['mkdHeading'], linksto: 'Title'},
  \   #{group: ['mkdCode', 'mkdCodeStart', 'mkdCodeEnd', 'mkdCodeDelimiter', 'markdownCodeDelimiter'], linksto: 'Comment'},
  \   #{group: ['mkdBold', 'htmlBold'], attrs: 'reverse'},
  \   #{group: ['mkdLink', 'mkdURL'], linksto: 'Underlined'},
  \ ]][1] +
  \ ['vimwiki', [
  \   #{group: ['VimwikiCheckBoxDone'], from: 'Comment', attrs: 'italic,strikethrough'},
  \ ]][1]

let g:my_theme_sync_fold_color=0
let g:my_theme_minimal_cursorline=1

let g:gopls_socket=$HOME.'/.sockets/gopls.sock'
" }}}

" SETTINGS {{{
" non-plugin autocmds in this file go in the vimrc group, make sure it's empty. also, for the sake
" of being explicit, require that autocmds specify the group name
aug vimrc | au! | aug end

" core settings
set encoding=utf-8
set autoread
set nofsync
set fileformats=unix
set backspace=indent,eol,start
set history=500 " remember this many ':' vim commands

" turn on titles
set title

" disable spellcheck
set nospell

" turn off visual bell otherwise it'll make tmux activity noisy
set noerrorbells
set novisualbell
set belloff=all
set t_vb=

" syntax highlighting for things that might have large data (32mb)
set maxmempattern=32768

" enable autoindent, but disable smartindent
set autoindent
set nosmartindent

" tab vs spaces 2: the whitespacening
" by default, assume 4 space tabs and automatically expand tabs to spaces
set tabstop=4 shiftwidth=4 softtabstop=4
set expandtab

" syntax highlighting is always on
syntax on

" the conceal feature is a bit too much magic for my taste
set concealcursor="" conceallevel=0

" enable filetype specific behaviors
filetype plugin indent on

" visual settings
set display=lastline
set showmatch
set nowrap

" break at word boundaries
set linebreak

" show both line number and relative numbers
set number relativenumber

" have some scroll context
set scrolloff=5

" what to show for cursor information
set cursorline nocursorcolumn

" prefer terminal-only modes
set guioptions-=T
set mouse=c

" for line wraps if we turn off wrapping, prefix with something
let &showbreak='❯ '

" status Line: always show and include the command
set laststatus=2
set showcmd

" tab completion for opening files and what not: <Tab>shows the list of matches, <Tab> a second
" time to go through the options. skip commonly ignored files
set wildmenu
set wildmode=list:longest,full
set wildignore=*.o,*~,*.pyc,*/.git/*,*/.hg/*,*/.svn/*,*/.DS_Store

" ui speed: prevent blocking refreshes and assume the terminal connection is fast
set lazyredraw
set ttyfast

" stop syntax highlights for long lines
set synmaxcol=256
" syntax sync minlines=64 maxlines=256
" syntax sync ccomment goComment
"
" add minlines=100 to scan back at least these many lines for a comment start which might give
" better context information
"
" add maxlines=500 to stop scanning this many lines back

" search settings
set ignorecase smartcase hlsearch incsearch

" diff options: ignore whitespace and use the better histogram algorithm
set diffopt+=vertical,iwhite

" hack: vim 8.2 blows up with this but i can't find a good check for it: has('patch-8.1.0360')
" doesn't work it would seem
try
  set diffopt+=algorithm:histogram
catch /E474/
endtry

" empty space fill behavior
" stl:       space - statusline
" stlnc:     space - statusline in other windows
" vert:      ┃     - vsplit separator
" foldopen:  ◇
" foldclose: ◆
" foldsep:   │     - fold span
" diff:      space - vimdiff removed filler
" eob: empty lines at buffer end
let &fillchars='stl: ,stlnc: ,vert:┃,foldopen:◇,foldclose:◆,foldsep:│,diff: ,eob:~'

" allow looking for custom settings in the first 5 lines
set modeline modelines=5

" some plugins add things to the sign column (ALE) so the screen doesn't go back and forth
set signcolumn=yes

" persist these things when saving a view
set viewoptions=folds,slash,unix

" views can get messed up with cursor position when folds are open or closed so reset the cursor
" position to the beginning of the file after loaded
au vimrc SessionLoadPost * 0

" set a maximum textwidth, but configure format options only wrap comments
set textwidth=110
set formatoptions=crqnj

" don't use 2 spaces after sentence ends
set nojoinspaces

" don't allow hidden buffers so when we close a file, it actually closes
set nohidden

" turn off swaps but enable backup files
set noswapfile
set backup backupext=.bak

" vim and neovim have different backup file formats, so use different locations
if has('nvim')
  set backupdir=$HOME/.vim/nvim-backup
else
  set backupdir=$HOME/.vim/backup
endif

" on mac, the default locations to skip for backups don't work because of symlinks
" and don't cover enough bases. make sure it works as expected
if has('mac')
  let &backupskip=&backupskip.',/private/var/*,/tmp/*'
endif

" use the system clipboard for text yanks
if has('linux')
  set clipboard=unnamedplus
else
  set clipboard=unnamed
endif

" add settings to support persistent undo
if has('persistent_undo')
  " save undo history (:help clear-undo)
  set undofile undolevels=500

  " keep neovim separate from regular vim
  if has('nvim')
    set undodir=$HOME/.vim/nvim-undo
  else
    set undodir=$HOME/.vim/undo
  endif

  " don't create an undofile for skipped backup files (e.g. /tmp)
  exec 'au vimrc BufNewFile,BufReadPost,BufWritePre ' . &backupskip . ' setlocal noundofile'
endif
" }}}

" KEYMAP {{{
" use spacebar as the leader key, default to a 500ms timeout to wait for keys
let mapleader="\<Space>"
set timeoutlen=500
set updatetime=500

" find/replace word under cursor
nn <Leader>R %s/<C-r><C-w>/

" toggle colorcolumn to visualize text wraps
nn <silent> <Leader><Bar><Bar> :exec 'set cc=' . (len(&cc) == 0 ? &textwidth : '')<CR>

" convert hex under cursor to decimal
" nn <Leader>0x %s/\([0-9a-fA-F]\{2\}\)/\=str2nr(submatch(1),16)/g

" tmux ctrl-a makes the increment number option useless, so remap it
no <C-k> <C-a>
no <C-j> <C-x>

nn <silent> <ESC><ESC> :lclose<CR>:cclose<CR>

" location list
nn <Leader>lo :lopen<CR>
nn <Leader>lq :lclose<CR>
nn <Leader>ln :lnext<CR>
nn <Leader>lp :lprevious<CR>

" quickfix
nn <Leader>co :copen<CR>
nn <Leader>cq :cclose<CR>
nn <Leader>cn :cnext<CR>
nn <Leader>cp :cprevious<CR>

" copy all
nn <Leader>A :%y<CR>

" working with tabs
nn <Leader>T :tabs<CR>
nn <Leader>tn :tabnew<CR>
nn <Leader>tl :tabnext<CR>
nn <Leader>th :tabprev<CR>
nn <leader>tq :tabclose<CR>
nn <Leader>tL :tabmove +1<CR>
nn <Leader>tH :tabmove -1<CR>
nn <Leader>to :tabonly<CR>

" smartindent comments:
" https://vim.fandom.com/wiki/Restoring_indent_after_typing_hash
ino # X<BS>#

" jq formtting, allow in both normal and visual block mode
no <Leader>jq :%!jq '.'<CR>

" disable macro recording
no q <Nop>

" visual block up/down movement
vn <C-J> :m '>+1<CR>gv=gv
vn <C-K> :m '<-2<CR>gv=gv

" decorated yank
vn <C-y> :call my#utils#decorated_yank()<CR>
vn <Leader>Y :call my#utils#decorated_yank()<CR>

" next/previous search item, but redraw the screen
nn n nzz
nn N Nzz

" conflict resolution {{{
" vim conflict resolutions. this is a little backwards in terms of how vim usually treats it.
" for the three way merge bufspec //2 will be ours (left side), //3 is theirs (right side).
" so these keymaps use > and < to point at which one you want
function! s:toggle_diff() abort
  if &diff
    only
  else
    exec 'Gvdiffsplit!'
  endif
endfunction

no <Leader>dd :call <SID>toggle_diff()<CR>
" FIXME: sort out how this should work
" au vimrc OptionSet diff {
"   exec (v:option_new == '1' ? 'no' : 'nun') . ' <buffer> <Leader>d>' . (v:option_new == '1' ? ' :diffg //3<CR>' : '')
"   exec (v:option_new == '1' ? 'no' : 'nun') . ' <buffer> <Leader>d<' . (v:option_new == '1' ? ' :diffg //2<CR>' : '')
"   exec (v:option_new == '1' ? 'no' : 'nun') . ' <buffer> <Leader>dn' . (v:option_new == '1' ? ' :cnext<CR>' : '')
"   exec (v:option_new == '1' ? 'no' : 'nun') . ' <buffer> <Leader>dp' . (v:option_new == '1' ? ' :cprevious<CR>' : '')
"   exec (v:option_new == '1' ? 'no' : 'nun') . ' <buffer> <Leader>dm' . (v:option_new == '1' ? ' :cclose<CR>:G mergetool<CR>' : '')
" }

" }}}

" when you want to adjust the tabs without remembering the commands
no <Leader>t2 :setlocal ts=2 sw=2 sts=2<CR>
no <Leader>t4 :setlocal ts=4 sw=4 sts=4<CR>

" }}}

" COLORS AND STYLE {{{
set background=dark

" terminal support {{{
" get termguicolors working (tested with mac)
" ref: https://tomlankhorst.nl/iterm-tmux-vim-true-color/
set termguicolors

" 256 color support
set t_Co=256

" rgb escape pattern for foreground and background colors
let &t_8f="\e[38;2;%lu;%lu;%lum"
let &t_8b="\e[48;2;%lu;%lu;%lum"

" disable 'background color erase'
set t_ut=

" TODO: set t_ts and t_fs to disable vim changing window titles

" italics support
let &t_ZH="\e[3m"
let &t_ZR="\e[23m"

" undercurl support
let &t_Cs="\e[4:3m"
let &t_Ce="\e[4:0m"

" underline color support: note that this uses colon instead of semicolon
let &t_8u="\e[58:2:%lu:%lu:%lum"
let &t_AU="\e[58:5:%lum"

" strikethrough support
let &t_Ts="\e[9m"
let &t_Te="\e[29m"

" }}}

" handle colorscheme updates
au vimrc ColorSchemePre * hi clear | syntax reset
" au vimrc ColorScheme,VimEnter,FileType * call my#themes#apply_theme_overrides()

" TODO: update airline when the colorscheme changes
" au vimrc ColorScheme * if get(g:,'loaded_airline',0) | call airline#switch_matching_theme() | endif

" apply whatever theme we're using
" exec 'colorscheme ' . g:my_theme

" colorscheme base16-ayu-dark
" colorscheme base16-da-one-black
" colorscheme base16-evenok-dark
" colorscheme base16-gigavolt
" colorscheme base16-gruber
" colorscheme base16-helios
" colorscheme base16-windows-95
" colorscheme base16-windows-10
" colorscheme base16-windows-highcontrast
" colorscheme base16-tender
" colorscheme base16-primer-dark
" colorscheme base16-isotope
" colorscheme ghdark
" colorscheme minimalist

" color settings when not using a my_theme
if !has_key(g:, 'my_theme')
  colorscheme ayu

  " manually apply overrides
  call my#themes#apply_theme_overrides()
endif

if has('nvim')
  " ensure that borders show up and look consistent
  hi clear FloatBorder | hi link FloatBorder Pmenu
endif

hi normal guibg=black
hi clear cursorline
" }}}

" FILETYPES {{{
" set *.pyx cython files as python syntax
au vimrc BufRead,BufNewFile *.pyx setfiletype python

" treat jsonl is json
" FIXME: these can be big so syntax so things will really slow down
au vimrc BufRead,BufNewFile *.jsonl setfiletype jsonl
au vimrc FileType json setlocal foldmethod=syntax

" Ruby, etc -> indent 2 spaces
au vimrc FileType ruby,haml,eruby,yaml,sass,cucumber,javascript,html,vim,bash,sh,zsh,toml,json,lua setlocal ts=2 sw=2 sts=2

" vim commentstring: the default one doesn't include a space after the double quote
au vimrc FileType vim setlocal commentstring=\"\ %s

" LaTeX commentstring: the default one is '%%s' which breaks my wrap plugin config, change it
au vimrc FileType tex setlocal foldmethod=marker commentstring=%\ %s

" sql commentstring: doesn't include any spacing
au vimrc FileType sql setlocal commentstring=--\ %s

" don't let plugins change my preferences (this makes any setl just use the global value)
au vimrc FileType vim,zsh setlocal formatoptions<

" markdown formatoptions: since it's documentation, enforce textwidth wrapping
au vimrc BufRead *.mkd,*.markdown,*.md setlocal fo+=t2

" makefiles have tabs
au vimrc FileType make setlocal ts=4 sw=4 sts=4 noet

" modifiable vim help docs shouldn't conceal because it's confusing, and we're editing
au vimrc BufEnter *.txt if &ft ==# 'help' && &modifiable | setfiletype text | endif

" }}}

" FOLDING {{{
" fold settings:
" - only 1 column for showing fold markers
" - set initial fold level to 99 to have all folds open
" - make folds open automatically for some events
set foldenable
set foldcolumn=1
set foldminlines=1
set foldnestmax=5
set foldlevel=99
set foldopen=tag,percent,search,mark,quickfix,undo,insert

" syntax folding is slow, default to manual unless in diff mode
if &diff
  set foldmethod=diff
else
  set foldmethod=manual
endif

" override foldtext to be more contextually aware
set foldtext=my#folds#foldtext()

" fold toggle shortcuts
nn <Leader><Leader> za

" better recursive close/open
nn <Leader>rzc :normal [zV]zzC<ESC>
nn <Leader>rzo :normal [zV]zzO<ESC>

" folding overrides {{{

" disable automatic folding when in insert mode. this prevents a problem where adding the
" start of a new marker fold unfolds everything below it
au vimrc InsertEnter * if !exists('w:lastfdm') | let w:lastfdm=&foldmethod | setlocal foldmethod=manual | endif
au vimrc InsertLeave * if exists('w:lastfdm') | let &l:foldmethod=w:lastfdm | unlet w:lastfdm | endif

" allow .proto folding based on curl brace and indent 4 spaces
au vimrc FileType proto setlocal foldmethod=marker foldmarker={,} ts=4 sw=4 sts=4

" dockerfiles to be folded with whatever the marker is
au vimrc FileType dockerfile setlocal foldmethod=marker

" filetypes that need more abbreviated fold text
au vimrc FileType markdown,python,yaml setlocal foldtext=my#folds#foldtext(0)

" filetypes that want explicitly manual folding
au vimrc FileType python,yaml setlocal foldmethod=manual

" whitelisted syntax folding files
au vimrc FileType go setlocal foldmethod=syntax

" }}}

" }}}

" PLUGIN SETTINGS {{{

" airline {{{
" i don't use a patched font (nor do i want to)
let g:airline_powerline_fonts=0
let g:airline_symbols_ascii=1

" theme
" let g:airline_theme=g:my_theme
let g:airline_theme='ayu_dark'

" config: section format {{{

" primary sections
" let g:airline_section_a       (mode, crypt, paste, spell, iminsert)
" let g:airline_section_b       (hunks, branch)[*]
" let g:airline_section_c       (bufferline or filename, readonly)
" let g:airline_section_gutter  (csv)
" let g:airline_section_x       (tagbar, filetype, virtualenv)
" let g:airline_section_y       (fileencoding, fileformat, 'bom', 'eol')

" section z: minimal info - current_line/num_lines:col_num
let g:airline_section_z='%#__accent_bold#%l/%L:%v%#__restore__#'

" let g:airline_section_error   (ycm_error_count, syntastic-err, eclim,
"                                languageclient_error_count)
" let g:airline_section_warning (ycm_warning_count, syntastic-warn,
"                                languageclient_warning_count, whitespace)

" section separators: i want simple boxes
let g:airline_left_sep=''
let g:airline_right_sep=''
let g:airline_left_sep_alt='|'
let g:airline_right_sep_alt='|'

" }}}

" custom symbols: mostly to use a halfway decent char without a patched font
if !exists('g:airline_symbols')
  let g:airline_symbols={}
endif
let g:airline_symbols.branch='⎇ '

" speedup load times
let g:airline_highlighting_cache=1

" disable modified detection and hide things for inactive windows
let g:airline_detect_modified=0
let g:airline_inactive_collapse=1

" don't show file encoding - it's wasted space
let g:airline#parts#ffenc#skip_expected_string='utf-8[unix]'

" show abbreviated mode names instead of the full string
" see :help mode()
let g:airline_mode_map_codes=1
let g:airline_mode_map={
  \ '__' : '--',
  \ 'n'  : 'N',
  \ 'i'  : 'I',
  \ 'R'  : 'R',
  \ 'c'  : 'C',
  \ 'v'  : 'V',
  \ 'V'  : 'V-L',
  \ '' : 'V-B',
  \ 's'  : 'S',
  \ 'S'  : 'S-L',
  \ '' : 'S-B',
  \ 't'  : 'T',
  \ 'r'  : 'P',
  \ 'rm' : 'P-M',
\ }

" extensions {{{
" FIXME: figure out why tabline always shows, look at fern
let g:airline_extensions=['branch', 'searchcount', 'zoomwintab']

" enabled extensions
let g:airline#extensions#branch#enabled=1
let g:airline#extensions#searchcount#enabled=1
let g:airline#extensions#tabline#enabled=1
let g:airline#extensions#tagbar#enabled=1
let g:airline#extensions#zoomwintab#enabled=1

if !has('nvim')
  let g:airline_extensions=add(g:airline_extensions, 'ale')
  let g:airline#extensions#ale#enabled=1
else
  " NOTE: we need to trick airline into thinking it's using a different plugin
  call lsp#init()

  let g:airline_extensions=add(g:airline_extensions, 'lsp')
  let g:airline#extensions#lsp#enabled=1
  let g:airline#extensions#lsp#show_line_numbers=0
endif

" promising extensions
" let g:airline#extensions#wordcount#enabled=1
" let g:airline#extensions#flog#enabled=1
" let g:airline#extensions#fern#enabled=1

" config: airline-tabline {{{
let g:airline#extensions#tabline#show_buffers=1
let g:airline#extensions#tabline#show_tabs=1
let g:airline#extensions#tabline#show_splits=0

let g:airline#extensions#tabline#tab_min_count=0
let g:airline#extensions#tabline#buffer_min_count=0

let g:airline#extensions#tabline#show_tab_count=2
let g:airline#extensions#tabline#exclude_preview=1

let g:airline#extensions#tabline#show_tab_nr=1
let g:airline#extensions#tabline#ctrlspace_show_tab_nr=1
let g:airline#extensions#tabline#tab_nr_type=1
let g:airline#extensions#tabline#tabnr_formatter='tabnr'

let g:airline#extensions#tabline#show_tab_type=0

let g:airline#extensions#tabline#buf_label_first=1
let g:airline#extensions#tabline#buffers_label='B'
let g:airline#extensions#tabline#tabs_label='T'
let g:airline#extensions#tabline#formatter='unique_tail_improved'
let g:airline#extensions#tabline#show_close_button=0

let g:airline#extensions#tabline#buffer_nr_show=1
let g:airline#extensions#tabline#buffer_nr_format='%s:'
" let g:airline#extensions#tabline#fnamemod = ':p:.'

" }}}

" config: airline-branch {{{
" abbrev commit without dirt/untracked checks
let g:airline#extensions#branch#vcs_checks=[]
let g:airline#extensions#branch#sha1_len=8
" }}}

" config: airline-tagbar {{{
" mirror settings for tagbar
let g:airline#extensions#tagbar#flags='f'
let g:airline#extensions#tagbar#searchmethod='nearest'
" }}}

" config: airline-zoomwintab {{{
" only show a marker for zoomed, make it consistent with tmux
let g:airline#extensions#zoomwintab#status_zoomed_in = '+++'
" }}}

" config: airline-ale {{{
let g:airline#extensions#ale#show_line_numbers=0
" }}}

" }}}

" }}}

" ale {{{
let g:ale_set_signs=1

" don't include govet with go linters - gopls does the same thing
let g:ale_linters={
  \ 'go': ['gopls', 'revive'],
  \ 'sh': [],
  \ 'bash': [],
  \ 'c': [],
  \ 'cpp': [],
  \ 'java': [],
  \ 'vim': ['ale_custom_linting_rules'],
\ }

" non-breaking spaces because i suppose ale trims strings
let s:sp=nr2char(160).nr2char(160)

let g:ale_sign_warning=s:sp
let g:ale_sign_error=s:sp

let g:ale_completion_enabled=0

let g:ale_echo_cursor=0
let g:ale_echo_msg_error_str='E'
let g:ale_echo_msg_warning_str='W'
let g:ale_echo_msg_info_str='I'
let g:ale_echo_msg_format='[%severity%] [%linter%] %s'

let g:ale_lint_on_insert_leave=1
let g:ale_lsp_suggestions=0
let g:ale_lsp_show_message_severity='error'
let g:ale_set_loclist=0
let g:ale_set_quickfix=1
let g:ale_set_highlights=0
let g:ale_list_window_size=5

" shortcuts
nn <Leader>an :ALENext<CR>
nn <Leader>at :ALEToggle<CR>

" linter config
let g:ale_go_revive_options='-format ndjson -config ~/.config/dotfiles/lint/revive.toml'
let g:ale_go_gopls_options='-remote "unix;'.g:gopls_socket.'"'

if has('nvim')
  let g:ale_use_neovim_diagnostics_api=1
  let g:ale_virtualtext_cursor='current'
endif

let g:ale_go_gopls_init_options={
  \ 'buildFlags': ['-tags', 'smartdns,pcap'],
  \ 'importShortcut': 'Link',
  \ 'ui.codelenses': {
  \   'tidy': v:false,
  \ },
  \ 'ui.diagnostic.analyses': {
  \   'asmdecl': v:false,
  \   'assign': v:false,
  \   'atomic': v:false,
  \   'atomicalign': v:false,
  \   'bools': v:false,
  \   'buildtag': v:true,
  \   'cgocall': v:true,
  \   'composites': v:true,
  \   'copylocks': v:true,
  \   'deepequalerrors': v:false,
  \   'embed': v:false,
  \   'errorsas': v:false,
  \   'fieldalignment': v:false,
  \   'httpresponse': v:false,
  \   'ifaceassert': v:false,
  \   'infertypeargs': v:true,
  \   'loopclosure': v:true,
  \   'lostcancel': v:true,
  \   'nilfunc': v:false,
  \   'nilness': v:true,
  \   'printf': v:true,
  \   'shadow': v:false,
  \   'shift': v:true,
  \   'simplifycompositelit': v:true,
  \   'simplifyrange': v:true,
  \   'simplifyslice': v:true,
  \   'sortslice': v:false,
  \   'stdmethods': v:true,
  \   'stringintconv': v:false,
  \   'structtag': v:false,
  \   'testinggoroutine': v:true,
  \   'tests': v:true,
  \   'timeformat': v:false,
  \   'unmarshal': v:false,
  \   'unreachable': v:false,
  \   'unsafeptr': v:false,
  \   'unusedparams': v:false,
  \   'unusedresult': v:false,
  \   'unusedwrite': v:true,
  \   'useany': v:true,
  \   'fillreturns': v:true,
  \   'nonewvars': v:true,
  \   'noresultvalues': v:true,
  \   'undeclaredname': v:true,
  \   'unusedvariable': v:true,
  \   'fillstruct': v:true,
  \   'stubmethods': v:false,
  \ }
\ }

let g:ale_use_global_executables=1

" floating preview {{{
let g:ale_cursor_detail=1
let g:ale_floating_preview=1
let g:ale_close_preview_on_insert=1
let g:ale_floating_preview_popup_opts='my#ale#get_popup_opts'
" }}}

" }}}

" tagbar : FIXME(figure out the full package view) {{{

" by default, don't run tagbar unless it's for specific filetypes
let b:tagbar_ignore=1
aug vimrc-plugin-tagbar | au!
  au BufNewFile,BufReadPost *.go let b:tagbar_ignore=0
aug end

let g:tagbar_compact=0 " 2 will show a blank line, no help
let g:tagbar_highlight_method='nearest'
let g:tagbar_iconchars=['▶ ', '▼ ']
let g:tagbar_position='topleft vertical'
let g:tagbar_show_data_type=0
let g:tagbar_show_linenumbers=0
let g:tagbar_show_tag_count=0
let g:tagbar_show_tag_linenumbers=0
let g:tagbar_show_visibility=0
let g:tagbar_silent=1
let g:tagbar_sort=1
let g:tagbar_use_cache=0
let g:tagbar_wrap=0

let g:tagbar_type_go={
	\ 'ctagstype': 'go',
	\ 'replace': 1,
	\ 'kinds': [
		\ 'p:package:0:0',
		\ 'i:imports:1:0',
		\ 'c:const:1:0',
		\ 'v:vars:1:0',
		\ 't:types',
		\ 'n:interfaces',
		\ 'w:fields',
		\ 'e:embedded',
		\ 'm:methods',
		\ 'r:constructor',
		\ 'f:functions'
	\ ],
	\ 'sro': '.',
	\ 'kind2scope': {
		\ 't': 'ctype',
		\ 'n': 'ntype'
	\ },
	\ 'scope2kind': {
		\ 'ctype': 't',
		\ 'ntype': 'n'
	\ },
	\ 'ctagsbin': 'gotags',
	\ 'ctagsargs': '-sort -silent'
\ }

" custom fork setting
let g:tagbar_dir_files=0

" colors
hi! link TagbarScope Normal
hi! link TagbarKind Comment
hi! link TagbarNestedKind Comment
hi! link TagbarSignature Normal

nn <Leader>tt :TagbarToggle<CR>

" }}}

" netrw {{{
let g:netrw_altv=1
let g:netrw_banner=0
let g:netrw_browse_split=0
let g:netrw_liststyle=3
let g:netrw_winsize=25
" }}}

" vim-go {{{
" vsplit the file when opening up the test
let g:go_alternate_mode='vsplit'

" FIXME: :GoAddWorkspace and :GoRun (<leader>g<cr> for that?)
" FIXME: fold text doesn't work for function sigs across multiple lines
"        i am not sure that the syntax fold logic handles them
" FIXME: i want a go-next-ref to follow a var in a function def
"
" NOTE: gu and gU make everything lower/upper (~ toggles case).
"       gw does what gq does but doesn't move cursor
"       = see 'equalprg'
"       g@ see 'operatorfunc'

" ask for types when we need them
let g:go_auto_type_info=0

" always prefer the package specific templates
let g:go_template_use_pkg=1

" no code completion
let g:go_code_completion_enabled=0
let g:go_code_completion_icase=0

" using ale for linting, not vim-go
let g:go_metalinter_enabled=[]
let g:go_metalinter_autosave_enabled=[]

" when to use gopls
let g:go_def_mode='gopls'
let g:go_info_mode='gopls'
let g:go_fmt_command='gopls'
let g:go_imports_mode='gopls'

" show quick docs in a popup
let g:go_doc_popup_window=1

" enable the terminal if we have it (it's nice to see what GoTest is doing)
if has('terminal')
  let g:go_term_enabled=1
  let g:go_term_mode='split'
endif

" use full formatting by default
call my#go#set_format_mode('full')

let g:go_fold_enable=['block', 'import', 'varconst', 'package_comment']

" gopls config (also see gopls api-json) {{{
let g:go_gopls_enabled=1
let g:go_gopls_options=['-remote', 'unix;'.g:gopls_socket]

" needed for some packages that get worked on
let g:go_build_tags='smartdns pcap'

" disable analyzers, ale is being used for that
let g:go_gopls_analyses={
  \ 'asmdecl': v:false,
  \ 'assign': v:false,
  \ 'atomic': v:false,
  \ 'atomicalign': v:false,
  \ 'bools': v:false,
  \ 'buildtag': v:false,
  \ 'cgocall': v:false,
  \ 'composites': v:false,
  \ 'copylocks': v:false,
  \ 'deepequalerrors': v:false,
  \ 'embed': v:false,
  \ 'errorsas': v:false,
  \ 'fieldalignment': v:false,
  \ 'httpresponse': v:false,
  \ 'ifaceassert': v:false,
  \ 'infertypeargs': v:false,
  \ 'loopclosure': v:false,
  \ 'lostcancel': v:false,
  \ 'nilfunc': v:false,
  \ 'nilness': v:true,
  \ 'printf': v:false,
  \ 'shadow': v:false,
  \ 'shift': v:false,
  \ 'simplifycompositelit': v:false,
  \ 'simplifyrange': v:false,
  \ 'simplifyslice': v:false,
  \ 'sortslice': v:false,
  \ 'stdmethods': v:false,
  \ 'stringintconv': v:false,
  \ 'structtag': v:false,
  \ 'testinggoroutine': v:false,
  \ 'tests': v:false,
  \ 'timeformat': v:false,
  \ 'unmarshal': v:false,
  \ 'unreachable': v:false,
  \ 'unsafeptr': v:false,
  \ 'unusedparams': v:false,
  \ 'unusedresult': v:false,
  \ 'unusedwrite': v:true,
  \ 'useany': v:true,
  \ 'fillreturns': v:false,
  \ 'nonewvars': v:false,
  \ 'noresultvalues': v:false,
  \ 'undeclaredname': v:false,
  \ 'unusedvariable': v:false,
  \ 'fillstruct': v:false,
  \ 'stubmethods': v:false,
\ }

" options: i'm not sure this actually works as advertised (or i misunderstand it)
let g:go_gopls_settings={
  \ 'importShortcut': 'Link',
\ }

let g:go_gopls_complete_unimported=v:false
let g:go_gopls_deep_completion=v:false
let g:go_gopls_gofumpt=v:true
let g:go_gopls_staticcheck=v:false
let g:go_diagnostics_level=0
" }}}

" add a little extra highlight color
let g:go_highlight_types=0
let g:go_highlight_extra_types=0
let g:go_highlight_functions=1
let g:go_highlight_string_spellcheck=0
let g:go_highlight_format_strings=1

" misc
let g:go_list_type='quickfix'
let g:go_snippet_engine='ultisnips'
let g:go_version_warning=0

" debug
" let g:go_debug=['lsp']

" func: s:on_filetype_go: function to run for FileType=go {{{
function! s:on_filetype_go() abort
  let g:go_gopls_local='gitlab.com/speedscale'

  " go uses tabs, not spaces
  setlocal noexpandtab

  " keybindings (neovim uses a different plugin) {{{
  if !has('nvim')
    nm <Leader>gd <Plug>(go-def)
    nm <Leader>gD <Plug>(go-def-type)
    nm <Leader>g? :GoDecls<CR>
    nm <Leader>g.? :GoDeclsDir<CR>
    nm <Leader>gA <Plug>(go-alternate-edit)!
    nm <Leader>gx <Plug>(go-doc)
    nm <Leader>gX <Plug>(go-doc-browser)
    nm <Leader>gc <Plug>(go-callers)
    nm <Leader>gr <Plug>(go-rename)
    nn <Leader>gI :GoImpl<CR>

    vn <Leader>gP :GoPlay<CR>

    " tests: all or just the function
    nm <Leader>gT :GoTest<CR>
    nm <Leader>gtv :GoTest -v<CR>
    nm <Leader>gtf :GoTestFunc -v<CR>

    " a way to quit a goterm buffer
    nm <Leader>gtq :bd goterm<CR>

    " use special behavior for these
    nn <Leader>gav :call go#alternate#Switch(!0, 'vsplit')<CR>
    nn <Leader>gas :call go#alternate#Switch(!0, 'split')<CR>
    nn <Leader>gA :GoAlternate!<CR>

    " vim-go GoDef utils
    nm <Leader>gsd <Plug>(go-def-split)
    nm <Leader>gvd <Plug>(go-def-vertical)
    nm <Leader>gsD <Plug>(go-def-type-split)
    nm <Leader>gvD <Plug>(go-def-type-vertical)

    " guru
    nm <Leader>ggd <Plug>(go-describe)
    nm <Leader>ggi <Plug>(go-implements)

    " change formatting behavior
    nm <Leader>gf0 :call my#go#set_format_mode('none')<CR>
    nm <Leader>gfs :call my#go#set_format_mode('simple')<CR>
    nm <Leader>gff :call my#go#set_format_mode('full')<CR>

    " other
    nm <Leader>gie <Plug>(go-if-err)
    nm <Leader>gta :GoAddTags<SPACE>
    nm <Leader>gtr :GoRemoveTags<CR>
    nm <Leader>gE <Plug>(go-extract)

    " tagbar alternative
    no <Leader>go :!go doc %:p:h<CR>
    no <Leader>g0 :!go doc -all %:p:h<CR>
  endif
  " }}}
endfunction
" }}}

" autocmd group: vim-go shortcuts and settings {{{
aug vimrc-plugin-vimgo | au!
  au FileType go call <SID>on_filetype_go()
  " au BufEnter *.go
aug end
" }}}
" }}}

" fugitive {{{
let g:fugitive_dynamic_colors=1
" }}}

" bling {{{
let g:bling_time=50
let g:bling_count=2
" }}}

" terraform {{{
let g:terraform_align=1
let g:terraform_fmt_on_save=0
" }}}

" undotree {{{
let g:undotree_WindowLayout=2
let g:undotree_ShortIndicators=1
let g:undotree_SplitWidth=30
let g:undotree_TreeNodeShape='•'
let g:undotree_DiffCommand='diff -U1'

nn <Leader>ut :UndotreeToggle<CR>
" }}}

" fastfold {{{
let g:fastfold_savehook=1

" let these handle folding on their own (presumably from lsp)
let g:fastfold_skip_filetypes=['go']
" }}}

" vim-commentary {{{
map <Leader>c gcc<ESC>
" }}}

" vim-surround {{{
" vim-surround settings
" ww: wrap word with <char>
" wl: wrap line with <char>
" wm: wrap with foldmarker
" wM = wrap with labeled foldmerker
nm <Leader>sw ysiW
nm <Leader>sl yss
nm <Leader>sm ySSm
nm <Leader>sM ySSM
vm <Leader>sm Sm
vm <Leader>sM SM

aug vimrc-plugin-surround | au!
  " support for wrapping with marker boundaries
  au BufEnter * call my#utils#set_marker_surround()
aug end
" }}}

" vim-which-key {{{
nn <silent> <Leader> :WhichKey '<Space>'<CR>
vn <silent> <Leader> :WhichKeyVisual '<Space>'<CR>
"}}}

" zoomwintab.vim {{{
nn <silent> <Leader>+ :ZoomWinTabToggle<CR>
" }}}

" quickpeek.vim {{{
nn <Leader>qp :QuickpeekToggle<CR>
" }}}

" ultisnips {{{
let g:UltiSnipsEditSplit='vertical'

" <c-space> is equivalent to <nul>, at least on mac
let g:UltiSnipsExpandTrigger='<nul>'
" }}}

" vim-markdown {{{
let g:vim_markdown_folding_disabled=0
let g:vim_markdown_folding_style_pythonic=1
let g:vim_markdown_override_foldtext=0
let g:vim_markdown_conceal=0
let g:vim_markdown_toc_autofit=0
let g:vim_markdown_fenced_languages=[
  \ 'go', 'go=golang',
  \ 'python', 'py=python', 'py3=python',
  \ 'shell=sh', 'bash=sh',
  \ ]
let g:vim_markdown_strikethrough=1
let g:vim_markdown_new_list_item_indent=2
let g:vim_markdown_edit_url_in='current'

aug vimrc-plugin-markdown | au!
  " disable the builtin markdown syntax and use vim-markdown
  au BufRead *.mkd,*.markdown,*.md let b:current_syntax='markdown'
aug end
" }}}

" buffergator {{{
let g:buffergator_show_full_directory_path=0
let g:buffergator_sort_regime='mru'
let g:buffergator_suppress_keymaps=1
let g:buffergator_tab_statusline=1
let g:buffergator_window_statusline=1

nn <Leader>bb :BuffergatorToggle<CR>
nn <Leader>bt :BuffergatorTabsToggle<CR>
" }}}

" goyo/limelight {{{
aug vimrc-plugin-goyo | au!
  " auto update width plus some padding
  au FileType markdown let g:goyo_width=&textwidth+4 | nn <Leader>G :Goyo<CR>

  " turn on writing mode
  au User GoyoEnter Limelight
  au User GoyoLeave Limelight!
aug end
" }}}

" fzf {{{
" search for the word under the cursor
nn <Leader>? :Ag <C-R><C-W><CR>

" Agd to use Ag with a different directory
function! s:ag_dir(bang, ...) abort
  call fzf#vim#grep(
    \ 'ag  --nogroup --column --color  -- ' . shellescape(join(a:000[1:])) .' ' . shellescape(a:000[0]), 1,
    \ fzf#vim#with_preview(), a:bang)
endfunction

command! -bang -nargs=* Agd call <SID>ag_dir(<bang>0, <f-args>)

let g:fzf_action = {
  \ 'ctrl-v': 'vsplit',
  \ 'ctrl-x': 'split',
\ }

" }}}

" vimwiki {{{
" reject list item: strikethrough
let g:vimwiki_auto_header=1
let g:vimwiki_conceal_onechar_markers=0
let g:vimwiki_conceal_pre=0
let g:vimwiki_conceallevel=0
let g:vimwiki_folding='custom'
let g:vimwiki_hl_cb_checked=2
let g:vimwiki_listsyms=' .x'
let g:vimwiki_tags_header='Tags'
let g:vimwiki_toc_link_format=0
let g:vimwiki_url_maxsave=0

" change the behavior so vimwiki is less aggressive with markdown files: they need to be a specific
" filetype .mdwiki. keep mediawiki .mw support though
let g:vimwiki_ext2syntax={'.mdwiki': 'markdown', '.mw': 'media'}

let g:vimwiki_list=[{
  \ 'name': 'My Wiki',
  \ 'path': '~/.vim/wiki',
  \ 'path_html': '~/.vim/wikihtml',
  \ 'automatic_nested_syntaxes': 1,
  \ 'list_margin': 0,
  \ 'auto_tags': 1,
  \ 'auto_toc': 0,
\ }]

" func: s:on_filetype_vimwiki: function to run for FileType=vimwiki {{{
function! s:on_filetype_vimwiki() abort
  " two space indent settings so it works more like markdown
  setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab

  " auto-wrap content like you would with markdown
  setlocal formatoptions+=t2

  " this is leaky if not setlocal
  setlocal conceallevel=2

  " overwrite fold settings to use custom foldtext
  setlocal foldmethod=expr
  setlocal foldtext=my#folds#foldtext(0,'','=\ ')
  setlocal foldexpr=VimwikiFoldLevel(v:lnum)

  " mappings for toggling todo items
  nn <buffer> <Leader>x <Plug>VimwikiToggleListItem
  vn <buffer> <Leader>x <Plug>VimwikiToggleListItem

  " FIXME: better indent/dedent controls
  " <Leader>&lt; -> glh
  " <Leader>&gt; -> gll
endfunction
" }}}

aug vimrc-plugin-vimwiki | au!
  au FileType vimwiki call <SID>on_filetype_vimwiki()
aug end
" }}}

" dap (neovim only) {{{
let g:dap_adapters = {'go': {'type': 'executable', 'command': 'dlv'}}

let g:dap_virtual_text = v:true
let g:dap_virtual_text_highlight = 'Comment'
let g:dap_debugger = 'go'
let g:dap_debugger_args = ['dap', '-l', '127.0.0.1:38697']
let g:dap_debugger_path = 'dlv'
let g:dap_debugger_log = v:true
let g:dap_debugger_port = 38697
let g:dap_virtual_text = v:true
let g:dap_virtual_text_highlight = 'Comment'
" }}}

" }}}

" neovim only: settings/modifiers
if has('nvim')
  aug vimrc-nvim-term | au!
    " begin terminal with insert mode instead of normal mode. also map <ESC> locally to put back into normal
    " mode (note it has to be buffer local otherwise it'll mess up fzf windows). also make it *VERY* apparent
    " that we're working in a terminal window
    au BufEnter term://* startinsert | tnoremap <buffer> <ESC> <C-\><C-N>

    " turn off line numbers when using the terminal in term mode
    au TermOpen term://* setlocal nonu nornu | startinsert | tnoremap <buffer> <ESC> <C-\><C-N>
    au TermEnter term://* setlocal nonu nornu
    au TermLeave term://* setlocal nu rnu

    " close automatically
    au TermClose term://* close

    " make commands to make term open easier
    command! -nargs=* Term split | terminal <args>
    command! -nargs=* VTerm vsplit | terminal <args>

    nn <Leader>ts :Term<CR>
    nn <Leader>tv :VTerm<CR>
  aug end

  aug vimrc-nvim-fzf | au!
    au FileType fzf tnoremap <buffer> <ESC> <C-Q>
  aug end
endif

" vi:fdm=marker:fml=1
